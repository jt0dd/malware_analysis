const Storage = require("./Storage.js");
const Register = require("./Register.js");
const Memory = require("./Memory.js");
const ArithmeticLogicUnit = require("./ArithmeticLogicUnit.js");
const bufferToHex = require("../funcs/bufferToHex");
const bufferToBin = require("../funcs/bufferToBin");
const opFieldDefs = require("../objects/opFieldDefs.js");
module.exports = class {
  constructor() {
    const registerContainers = {
      CPU: [],
      GPR: [],
      MMX: [],
      // ...
    };

    // Allocate GPRs
    for (let i = 0; i < 16; i++) {
      registerContainers.GPR.push(new ArrayBuffer(8));
    }

    // Allocate CPU
    registerContainers.CPU.push(new ArrayBuffer(8));

    this.ALU = new ArithmeticLogicUnit();
    this.memory = new Memory();
    this.storage = new Storage();
    this.registers = {};
    this.registerContainers = registerContainers;

    // # Special Internal Registers

    this.registers["rip"] = new Register(registerContainers.CPU[0], 0, 64);

    // # General Purpose Registers

    /*
  
      Note: Usage during syscall/function call:
  
          - First six arguments are in rdi, rsi, rdx, rcx, r8d, r9d; remaining arguments are on 
            the stack.
          - For syscalls, the syscall number is in rax.
          - Return value is in rax.
          - The called routine is expected to preserve rsp, rbp, rbx, r12, r13, r14, and r15 but
            may trample any other registers.
  
      */

    this.registers["rax"] = new Register(registerContainers.GPR[0], 0, 64); // Register A Extended
    this.registers["eax"] = new Register(registerContainers.GPR[0], 4, 32);
    this.registers["ax"] = new Register(registerContainers.GPR[0], 6, 16); // multiply/divide, string load & store
    this.registers["ah"] = new Register(registerContainers.GPR[0], 6, 8);
    this.registers["al"] = new Register(registerContainers.GPR[0], 7, 8);

    this.registers["rbx"] = new Register(registerContainers.GPR[1], 0, 64); // Register B Extended
    this.registers["ebx"] = new Register(registerContainers.GPR[1], 4, 32);
    this.registers["bx"] = new Register(registerContainers.GPR[1], 6, 16); // index register for MOVE
    this.registers["bh"] = new Register(registerContainers.GPR[1], 6, 8);
    this.registers["bl"] = new Register(registerContainers.GPR[1], 7, 8);

    this.registers["rcx"] = new Register(registerContainers.GPR[2], 0, 64); // Register C Extended
    this.registers["ecx"] = new Register(registerContainers.GPR[2], 4, 32);
    this.registers["cx"] = new Register(registerContainers.GPR[2], 6, 16); // count for string operations & shifts
    this.registers["ch"] = new Register(registerContainers.GPR[2], 6, 8);
    this.registers["cl"] = new Register(registerContainers.GPR[2], 7, 8);

    this.registers["rdx"] = new Register(registerContainers.GPR[3], 0, 64); // Register D Extended
    this.registers["edx"] = new Register(registerContainers.GPR[3], 4, 32);
    this.registers["dx"] = new Register(registerContainers.GPR[3], 6, 16); // port address for IN and OUT
    this.registers["dh"] = new Register(registerContainers.GPR[3], 6, 8);
    this.registers["dl"] = new Register(registerContainers.GPR[3], 7, 8);

    // ## Pointer Registers

    /*
  
      Note: Other usage of pointers:
  
          - AX multiply/divide, string load & store
          - BX index register for MOVE
          - CX count for string operations & shifts
          - DX port address for IN and OUT
          - SP points to top of the stack
          - BP points to base of the stack frame
          - SI points to a source in stream operations
          - DI points to a destination in stream operations
  
      */

    this.registers["rsp"] = new Register(registerContainers.GPR[4], 0, 64);
    this.registers["esp"] = new Register(registerContainers.GPR[4], 4, 32);
    this.registers["sp"] = new Register(registerContainers.GPR[4], 6, 16); // points to top of the stack
    this.registers["spl"] = new Register(registerContainers.GPR[4], 7, 8);

    this.registers["rbp"] = new Register(registerContainers.GPR[5], 0, 64);
    this.registers["ebp"] = new Register(registerContainers.GPR[5], 4, 32);
    this.registers["bp"] = new Register(registerContainers.GPR[5], 6, 16); // points to base of the stack frame
    this.registers["bpl"] = new Register(registerContainers.GPR[5], 7, 8);

    this.registers["rsi"] = new Register(registerContainers.GPR[6], 0, 64);
    this.registers["esi"] = new Register(registerContainers.GPR[6], 4, 32);
    this.registers["si"] = new Register(registerContainers.GPR[6], 6, 16); // points to a source in stream operations
    this.registers["sil"] = new Register(registerContainers.GPR[6], 7, 8);

    this.registers["rdi"] = new Register(registerContainers.GPR[7], 0, 64);
    this.registers["edi"] = new Register(registerContainers.GPR[7], 4, 32);
    this.registers["di"] = new Register(registerContainers.GPR[7], 6, 16); // points to a destination in stream operations
    this.registers["dil"] = new Register(registerContainers.GPR[7], 7, 8);

    // ## Data Registers

    this.registers["r8"] = new Register(registerContainers.GPR[8], 0, 64);
    this.registers["r8d"] = new Register(registerContainers.GPR[8], 4, 32);
    this.registers["r8w"] = new Register(registerContainers.GPR[8], 6, 16);
    this.registers["r8b"] = new Register(registerContainers.GPR[8], 7, 8);

    this.registers["r9"] = new Register(registerContainers.GPR[9], 0, 64);
    this.registers["r9d"] = new Register(registerContainers.GPR[9], 4, 32);
    this.registers["r9w"] = new Register(registerContainers.GPR[9], 6, 16);
    this.registers["r9b"] = new Register(registerContainers.GPR[9], 7, 8);

    this.registers["r10"] = new Register(registerContainers.GPR[10], 0, 64);
    this.registers["r10d"] = new Register(registerContainers.GPR[10], 4, 32);
    this.registers["r10w"] = new Register(registerContainers.GPR[10], 6, 16);
    this.registers["r10b"] = new Register(registerContainers.GPR[10], 7, 8);

    this.registers["r11"] = new Register(registerContainers.GPR[11], 0, 64);
    this.registers["r11d"] = new Register(registerContainers.GPR[11], 4, 32);
    this.registers["r11w"] = new Register(registerContainers.GPR[11], 6, 16);
    this.registers["r11b"] = new Register(registerContainers.GPR[11], 7, 8);

    this.registers["r12"] = new Register(registerContainers.GPR[12], 0, 64);
    this.registers["r12d"] = new Register(registerContainers.GPR[12], 4, 32);
    this.registers["r12w"] = new Register(registerContainers.GPR[12], 6, 16);
    this.registers["r12b"] = new Register(registerContainers.GPR[12], 7, 8);

    this.registers["r13"] = new Register(registerContainers.GPR[13], 0, 64);
    this.registers["r13d"] = new Register(registerContainers.GPR[13], 4, 32);
    this.registers["r13w"] = new Register(registerContainers.GPR[13], 6, 16);
    this.registers["r13b"] = new Register(registerContainers.GPR[13], 7, 8);

    this.registers["r14"] = new Register(registerContainers.GPR[14], 0, 64);
    this.registers["r14d"] = new Register(registerContainers.GPR[14], 4, 32);
    this.registers["r14w"] = new Register(registerContainers.GPR[14], 6, 16);
    this.registers["r14b"] = new Register(registerContainers.GPR[14], 7, 8);

    this.registers["r15"] = new Register(registerContainers.GPR[15], 0, 64);
    this.registers["r15d"] = new Register(registerContainers.GPR[15], 4, 4);
    this.registers["r15w"] = new Register(registerContainers.GPR[15], 6, 16);
    this.registers["r15b"] = new Register(registerContainers.GPR[15], 7, 8);
  }
  mount(executable, address = 0x0) {
    console.assert(executable.textSegment.constructor === Uint8Array);
    this.memory.write(address, executable.textSegment);
  }
  fetch() {
    const rip = this.registers["rip"].read();
    console.log("fetching instruction at rip address:", rip);
    let byte = this.memory.read(rip, 1);
    let bytes = 0n
    const fields = {}
    console.log(
      "fetched first instruction byte:",
      byte,
      "[",
      bufferToHex(byte),
      "]"
    );
    const flags = [
      this.memory.readBit(rip, 7),
      this.memory.readBit(rip, 6),
      this.memory.readBit(rip, 5),
      this.memory.readBit(rip, 4),
      this.memory.readBit(rip, 3),
      this.memory.readBit(rip, 2), 
      this.memory.readBit(rip, 1), 
      this.memory.readBit(rip, 0)
    ];
    for (let i = 0; i < opFieldDefs.length; i++) {
      const fieldResult = opFieldDefs[i](byte, flags);
      if (fieldResult) {
        fields[fieldResult.field] = fieldResult
        bytes++
        byte = this.memory.read(rip + bytes, 1);
      }
    }
    console.log('fetched byte, fields', fields)
  }
  decode() {}
  execute() {}
  step() {
    this.fetch();
    this.decode();
    this.execute();
  }
};

module.exports = class {
  constructor() {
    this.addresses = {};
  }
  write(address, buffer) {
    console.assert(buffer && buffer.constructor === Uint8Array);
    const addresses = Object.keys(this.addresses);
    for (let i = 0; addresses.length; i++) {
      let oldBufferAddr = parseInt(addresses[i]);
      let addressBuffer = this.addresses[oldBufferAddr];
      if (
        address >= oldBufferAddr &&
        address <= oldBufferAddr + addressBuffer.length
      ) {
        // address range exists, modify
        addressBuffer.set(buffer, address - oldBufferAddr);
        return;
      }
    }
    // otherwise write a new address
    this.addresses[address] = buffer;
  }
  read(address, bytes) {
    if (this.addresses[address]) {
      return this.addresses[address].slice(0, bytes);
    } else {
        const addresses = Object.keys(this.addresses);
        for (let i = 0; addresses.length; i++) {
            let oldBufferAddr = addresses[i];
            let addressBuffer = this.addresses[oldBufferAddr];
            if (
              address >= oldBufferAddr &&
              address <= oldBufferAddr + addressBuffer.length
            ) {
              // address range exists, modify
              const byte = addressBuffer.slice(Number(address) - oldBufferAddr, 1);
              return byte;
            }
          }
    }
  }
  writeBit(address, bit, value) {
    const buffer = this.read(address, 1);
    if (value == 0) {
      buffer[0] &= ~(1 << bit);
    } else {
      buffer[0] |= 1 << bit;
    }
    this.write(address, buffer);
  }
  readBit(address, bitIndex) {
    console.assert(bitIndex < 8);
    //const bytes = Math.ceil(bitIndex / 8)
    //const byte = ~~(bitIndex / 8); // which byte to look at
    //console.log();
    const bit = bitIndex % 8; // which bit within the byte to look at
    const targetByte = this.read(address, 1); // grab the byte from the buffer
    if (targetByte & Math.pow(2, 7 - bit)) return 1;
    return 0;
  }
};
